-- -*-haskell-*-
--  GIMP Toolkit (GTK) Binding for Haskell: Widget StatusBar
--
--  Author : Axel Simon
--          
--  Created: 23 May 2001
--
--  Version $Revision: 1.1.1.1 $ from $Date: 2002/03/24 21:56:19 $
--
--  Copyright (c) [1999.2001] Manuel Chakravarty, Axel Simon
--
--  This file is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This file is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--- DESCRIPTION ---------------------------------------------------------------
--
-- * GtkStatusbar -- report messages of minor importance to the user.
--
--- DOCU ----------------------------------------------------------------------
--
-- * A Statusbar is usually placed along the bottom of an application's main
--   Window. It may provide a regular commentary of the application's status 
--   (as is usually the case in a web browser, for example), or may be used to
--   simply output a message when the status changes, (when an upload is 
--   complete in an FTP client, for example).
--   Status bars in Gtk+ maintain a stack of messages. The message at the top
--   of the each bar's stack is the one that will currently be displayed.
--   Any messages added to a statusbar's stack must specify a ContextId that
--   is used to uniquely identify the source of a message. This ContextId can
--   be generated by statusbarGetContextId, given a message and the statusbar
--   that it will be added to. Note that messages are stored in a stack, and
--   when choosing which message to display, the stack structure is adhered
--   to, regardless of the context identifier of a message.
--   Messages are added to the bar's stack with statusbarPush. The message at
--   the top of the stack can be removed using statusbarPop. A message can be
--   removed from anywhere in the stack if it's MessageId was recorded at the
--   time it was added. This is done using statusbarRemove.
--
--- TODO ----------------------------------------------------------------------

module Statusbar(
  Statusbar,
  StatusbarClass,
  castToStatusbar,
  statusbarNew,
  statusbarGetContextId,
  statusbarPush,
  statusbarPop,
  statusbarRemove,
  statusbarSetHasResizeGrip,
  statusbarGetHasResizeGrip,
  connectToTextPopped,
  connectToTextPushed
  ) where

import Monad	(liftM)
import Foreign
import UTFCForeign
import Object	(makeNewObject)
{#import Hierarchy#}
{#import Signal#}

{# context lib="gtk" prefix="gtk" #}

-- methods

-- Create a new Statusbar. (EXPORTED)
--
statusbarNew :: IO Statusbar
statusbarNew = makeNewObject mkStatusbar $ 
  liftM castPtr {#call unsafe statusbar_new#}

type ContextId = {#type guint#}

-- Given a context description, this function returns a ContextId.
-- This id can be used to later remove entries form the Statusbar. (EXPORTED)
--
statusbarGetContextId :: StatusbarClass sb => String -> sb -> IO ContextId
statusbarGetContextId description sb = withCString description $
  {#call unsafe statusbar_get_context_id#} (toStatusbar sb)


type MessageId = {#type guint#}

-- Push a new message on the Statusbar stack. It will be displayed as long
-- as it is on top of the stack. (EXPORTED)
--
statusbarPush :: StatusbarClass sb => ContextId -> String -> sb -> IO MessageId
statusbarPush context msg sb = withCString msg $ {#call statusbar_push#}
  (toStatusbar sb) context

-- Pops the topmost message that has the correct context. (EXPORTED)
--
statusbarPop :: StatusbarClass sb => ContextId -> sb -> IO ()
statusbarPop context sb = {#call statusbar_pop#} (toStatusbar sb) context

-- Remove an entry within the stack. (EXPORTED)
--
statusbarRemove :: StatusbarClass sb => ContextId -> MessageId -> sb -> IO ()
statusbarRemove context message sb = {#call statusbar_remove#} (toStatusbar sb)
  context message

-- Toggle the displaying of a resize grip. (EXPORTED)
--
statusbarSetHasResizeGrip :: StatusbarClass sb => Bool -> sb -> IO ()
statusbarSetHasResizeGrip set sb = {#call statusbar_set_has_resize_grip#}
  (toStatusbar sb) (fromBool set)

-- Query the displaying of the resize grip. (EXPORTED)
--
statusbarGetHasResizeGrip :: StatusbarClass sb => sb -> IO Bool
statusbarGetHasResizeGrip sb = liftM toBool $
  {#call unsafe statusbar_get_has_resize_grip#} (toStatusbar sb)

-- signals

-- Called if a message is removed. (EXPORTED)
--
connectToTextPopped :: StatusbarClass sb => 
  (ContextId -> String -> IO ()) -> ConnectAfter -> sb -> IO (ConnectId sb)
connectToTextPopped = connect_WORD_STRING__NONE "text-popped"

-- Called if a message is pushed on top of the stack. (EXPORTED)
--
connectToTextPushed :: StatusbarClass sb =>
  (ContextId -> String -> IO ()) -> ConnectAfter -> sb -> IO (ConnectId sb)
connectToTextPushed = connect_WORD_STRING__NONE "text-pushed"

