; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

[Setup]
AppName=Gtk2Hs
AppId=Gtk2Hs
AppVerName=Gtk2Hs @VERSION@
AppVersion=@VERSION@
AppPublisher=The Gtk2Hs Team
AppPublisherURL=http://haskell.org/gtk2hs/
AppSupportURL=http://haskell.org/gtk2hs/
AppUpdatesURL=http://haskell.org/gtk2hs/

DefaultDirName={pf}\Gtk2Hs
OutputBaseFilename=gtk2hs-@VERSION@
Compression=lzma/max
SolidCompression=yes

[Components]
Name: "gtk";    Description: "Gtk+ libraries"; Types: full compact custom; Flags: fixed
Name: "gtk2hs"; Description: "Gtk2Hs libraries"; Types: full compact custom; Flags: fixed
Name: "docs";   Description: "API reference documentation"; Types: full
Name: "demos";  Description: "Source files for the Gtk2Hs demo programs"; Types: full

[Files]
Source: "gtk+-2.10.8\*"; DestDir: "{app}"; Components: gtk; Flags: ignoreversion recursesubdirs createallsubdirs;
Source: "gtk2hs-@VERSION@-ghc-6.4.2-gtk-2.10\*"; DestDir: "{app}"; Components: gtk2hs; Check: UseWithGhcVersion('6.4.2'); Flags: ignoreversion recursesubdirs createallsubdirs; AfterInstall: AfterPkgInstall;
Source: "gtk2hs-@VERSION@-ghc-6.6-gtk-2.10\*";   DestDir: "{app}"; Components: gtk2hs; Check: UseWithGhcVersion('6.6'); Flags: ignoreversion recursesubdirs createallsubdirs; AfterInstall: AfterPkgInstall;
Source: "gtk2hs-@VERSION@-demo\*"; DestDir: "{app}\demos"; Components: demos; Flags: ignoreversion recursesubdirs createallsubdirs;
Source: "gtk2hs-@VERSION@-docs\*"; DestDir: "{app}\docs";  Components: docs;  Flags: ignoreversion recursesubdirs createallsubdirs;
Source: "COPYING.txt"; DestDir: "{app}"; Components: gtk2hs; Flags: ignoreversion;
Source: "AUTHORS.txt"; DestDir: "{app}"; Components: gtk2hs; Flags: ignoreversion;

[Registry]
Root: HKCU; Subkey: "Environment"; ValueName: "PATH"; ValueType: "string"; ValueData: "{app}\bin;{olddata}"; Check: NotOnPathAlready(); Flags: preservestringtype;

[Run]
Filename: "{code:ghcpkg}"; Parameters: "update ""{app}\glib.package.conf""";  StatusMsg: "Registering glib package...";  Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "update ""{app}\cairo.package.conf"""; StatusMsg: "Registering cairo package..."; Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "update ""{app}\gtk.package.conf""";   StatusMsg: "Registering gtk package...";   Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "update ""{app}\glade.package.conf"""; StatusMsg: "Registering glade package..."; Flags: runhidden
; Filename: "{code:ghcpkg}"; Parameters: "update ""{app}\gtkgl.package.conf"""; StatusMsg: "Registering gtkgl package..."; Flags: runhidden

[UninstallRun]
; Filename: "{code:ghcpkg}"; Parameters: "unregister gtkgl-0.9.10.4"; RunOnceId: "gtkgl"; Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "unregister glade-0.9.10.4"; RunOnceId: "glade"; Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "unregister gtk-0.9.10.4";   RunOnceId: "gtk";   Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "unregister cairo-0.9.10.4"; RunOnceId: "cairo"; Flags: runhidden
Filename: "{code:ghcpkg}"; Parameters: "unregister glib-0.9.10.4";  RunOnceId: "glib";  Flags: runhidden

[Code]
var
  GhcInstallDir: String;
  GhcInstallVersion: String;
  
  CheckingPage: TOutputProgressWizardPage;
  ErrorReportPage: TOutputMsgWizardPage;

function ghcpkg(Param: String): String;
begin
  Result := AddBackslash(GhcInstallDir) + 'bin\ghc-pkg.exe';
end;

function UseWithGhcVersion(const GhcVersion: String): Boolean;
begin
  Result := (GhcVersion = GhcInstallVersion);
end;

function NotOnPathAlready(): Boolean;
var
  BinDir, Path: String;
begin
  Log('Checking if Gtk2Hs\bin dir is already on the %PATH%');
  if RegQueryStringValue(HKEY_CURRENT_USER, 'Environment', 'PATH', Path) then
  begin // Successfully read the value
    Log('HKCU\Environment\PATH = ' + Path);
    BinDir := ExpandConstant('{app}\bin');
    Log('Looking for Gtk2Hs\bin dir in %PATH%: ' + BinDir + ' in ' + Path);
    if Pos(LowerCase(BinDir), Lowercase(Path)) = 0 then
    begin
      Log('Did not find Gtk2Hs\bin dir in %PATH% so will add it');
      Result := True;
    end
    else
    begin
      Log('Found Gtk2Hs bin dir in %PATH% so will not add it again');
      Result := False;
    end
  end
  else // The key probably doesn't exist
  begin
    Log('Could not access HKCU\Environment\PATH so assume it is ok to add it');
    Result := True;
  end;
end;

{ exec a program and return its output }
function ExecOutput(const Filename, Params: String): String;
var
  TmpFile: String;
  ResultCode: Integer;
begin
  Result := '';
  TmpFile := GenerateUniqueName(ExpandConstant('{tmp}'), 'tmp');
  if Exec(ExpandConstant('{cmd}'), '/C ' + Filename + ' ' + Params + ' > ' + TmpFile,
     '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    if ResultCode = 0 then
      if LoadStringFromFile(TmpFile, Result) then
      begin
        Result := Trim(Result);
        Log('ExecOutput: running ' + Filename + ' succeded with output: ' + Result);
      end
      else
        Log('ExecOutput: running ' + Filename + ' succeded, but the temp file was not created')
    else
      Log('ExecOutput: running ' + Filename + ' failed, code: ' + IntToStr(ResultCode))
  else
    { That's really odd, we should always be able to exec the command interpreter! }
    Log('ExecOutput: cannot exec command interpreter, code: ' + IntToStr(ResultCode) + ', message: ' + SysErrorMessage(ResultCode));
end;

function CheckGhcVersionIsOk(const Path: String; var Version: String):Boolean;
begin
  Version := ExecOutput(AddBackslash(Path) + 'bin\ghc.exe', '--numeric-version');
  GhcInstallVersion := Version;
  
  Result := (Version = '6.4.2')
         or (Version = '6.6');
end;

function DetectValidGhcInstallation(): Boolean;
var
  HaveSomeGHCInstalled: Boolean;
  GHCVersion: String;

begin
  Result := False;

  { first check for ghc on the path, then look in the registry }
  
  begin
    GhcInstallDir := ExecOutput('ghc.exe', '--print-libdir');
    if GhcInstallDir <> '' then
    begin
      StringChange(GhcInstallDir, '/', '\');
      Log('DetectValidGhcInstallation: found ghc on %PATH% with libdir: ' + GhcInstallDir);
      HaveSomeGHCInstalled := True;
      Result := CheckGhcVersionIsOk(GhcInstallDir, GHCVersion);
    end;
  end;

  if (Result = False) and RegKeyExists(HKEY_CURRENT_USER, 'Software\Haskell\GHC') then
  begin
    Log('DetectValidGhcInstallation: found HKCU\Software\Haskell\GHC');
    HaveSomeGHCInstalled := True;
    RegQueryStringValue(HKEY_CURRENT_USER, 'Software\Haskell\GHC\ghc-6.6', 'InstallDir', GhcInstallDir);
    Result := CheckGhcVersionIsOk(GhcInstallDir, GHCVersion);
  end;

  if (Result = False) and RegKeyExists(HKEY_CURRENT_USER, 'Software\Haskell\GHC') then
  begin
    Log('DetectValidGhcInstallation: found HKCU\Software\Haskell\GHC');
    HaveSomeGHCInstalled := True;
    RegQueryStringValue(HKEY_CURRENT_USER, 'Software\Haskell\GHC\ghc-6.4.2', 'InstallDir', GhcInstallDir);
    Result := CheckGhcVersionIsOk(GhcInstallDir, GHCVersion);
  end;

  if (Result = False) and RegKeyExists(HKEY_LOCAL_MACHINE, 'SOFTWARE\Haskell\GHC') then
  begin
    Log('DetectValidGhcInstallation: found HKLM\SOFTWARE\Haskell\GHC');
    HaveSomeGHCInstalled := True;
    RegQueryStringValue(HKEY_LOCAL_MACHINE, 'SOFTWARE\Haskell\GHC\ghc-6.6', 'InstallDir', GhcInstallDir);
    Result := CheckGhcVersionIsOk(GhcInstallDir, GHCVersion);
  end;

  if (Result = False) and RegKeyExists(HKEY_LOCAL_MACHINE, 'SOFTWARE\Haskell\GHC') then
  begin
    Log('DetectValidGhcInstallation: found HKLM\SOFTWARE\Haskell\GHC');
    HaveSomeGHCInstalled := True;
    RegQueryStringValue(HKEY_LOCAL_MACHINE, 'SOFTWARE\Haskell\GHC\ghc-6.4.2', 'InstallDir', GhcInstallDir);
    Result := CheckGhcVersionIsOk(GhcInstallDir, GHCVersion);
  end;

  if Result then
    Log('DetectValidGhcInstallation: correct version of ghc found at: ' + GhcInstallDir)
  else if HaveSomeGHCInstalled and (GHCVersion <> '') then
  begin
    Log('DetectValidGhcInstallation: incorrect ghc version installed: ' + GHCVersion);
    SuppressibleMsgBox('This version of Gtk2Hs requires GHC version 6.6 or 6.4.2 (found GHC version ' + GHCVersion + ')', mbError, MB_OK, IDOK);
  end
  else if HaveSomeGHCInstalled and (GhcInstallDir <> '') then
  begin
    Log('DetectValidGhcInstallation: some non-working version of ghc appears to be installed at: ' + GhcInstallDir);
    SuppressibleMsgBox('GHC does not appear to be installed correctly, try reinstalling GHC version 6.6 or 6.4.2', mbError, MB_OK, IDOK);
  end
  else if HaveSomeGHCInstalled then
  begin
    Log('DetectValidGhcInstallation: corrupted ghc installation detected, probably messed up registry keys');
    SuppressibleMsgBox('GHC does not appear to be installed (or the installation is corrupted), please install GHC version 6.2.2 or 6.4.1', mbError, MB_OK, IDOK);
  end
  else
  begin
    Log('DetectValidGhcInstallation: no installation of ghc detected');
    SuppressibleMsgBox('Gtk2Hs requires GHC to be installed first, please install GHC version 6.2.2 or 6.4.2', mbError, MB_OK, IDOK);
  end;

end;

procedure ParseVersionString(Version: String; var MajorVersion, MinorVersion, MicroVersion: Integer);
var
  N, M : Integer;
  MajorVersionStr, MinorVersionStr, MicroVersionStr: String;
begin
  N := 1;
  M := 1;
  SetLength(MajorVersionStr, Length(Version));
  while (N < Length(Version) + 1) and (Version[N] >= '0') and (Version[N] <= '9') do
  begin
    MajorVersionStr[M] := Version[N];
    N := N + 1; M := M + 1;
  end;
  SetLength(MajorVersionStr, M - 1);

  while (N < Length(Version) + 1) and ((Version[N] < '0') or (Version[N] > '9')) do
    N := N + 1;

  M := 1;
  SetLength(MinorVersionStr, Length(Version));
  while (N < Length(Version) + 1) and (Version[N] >= '0') and (Version[N] <= '9') do
  begin
    MinorVersionStr[M] := Version[N];
    N := N + 1; M := M + 1;
  end;
  SetLength(MinorVersionStr, M - 1);

  while (N < Length(Version) + 1) and ((Version[N] < '0') or (Version[N] > '9')) do
    N := N + 1;

  M := 1;
  SetLength(MicroVersionStr, Length(Version));
  while (N < Length(Version) + 1) and (Version[N] >= '0') and (Version[N] <= '9') do
  begin
    MicroVersionStr[M] := Version[N];
    N := N + 1; M := M + 1;
  end;
  SetLength(MicroVersionStr, M - 1);
  
  MajorVersion := StrToIntDef(MajorVersionStr, 0);
  MinorVersion := StrToIntDef(MinorVersionStr, 0);
  MicroVersion := StrToIntDef(MicroVersionStr, 0);

  Log('ParseVersionString: Version = ' + Version);
  Log('ParseVersionString: MajorVersion = ' + IntToStr(MajorVersion));
  Log('ParseVersionString: MinorVersion = ' + IntToStr(MinorVersion));
  Log('ParseVersionString: MicroVersion = ' + IntToStr(MicroVersion));
end;

var
  ChecksOk : Boolean;

function NextButtonClick(CurPageID: Integer): Boolean;
var
  I: Integer;
begin
  Log('NextButtonClick: CurPageID = ' + IntToStr(CurPageID));
  if CurPageID = wpWelcome then
    Result := DetectValidGhcInstallation()
  else
    Result := True;
end;

procedure PackageFileVarSubstitute(const PackageFile: String);
var
  PackageFileContent: String;
  PackageLibDir: String;
begin
  PackageLibDir := ExpandConstant('{app}');
  StringChange(PackageLibDir, '\', '/');
  
  LoadStringFromFile(PackageFile, PackageFileContent);

  StringChange(PackageFileContent, '${pkglibdir}', PackageLibDir);
  StringChange(PackageFileContent, '${GTK_BASEPATH}', PackageLibDir);
  
  SaveStringToFile(PackageFile, PackageFileContent, False);
  Log('Expanding variables in ' + PackageFile);
end;

procedure AfterPkgInstall;
begin
  if (ExtractFileExt(CurrentFileName) = '.conf') then
    PackageFileVarSubstitute(ExpandConstant(CurrentFileName));
end;

// Detect when the ready info page gets displayed
function UpdateReadyMemo(Space, NewLine, MemoUserInfoInfo, MemoDirInfo,
                         MemoTypeInfo, MemoComponentsInfo, MemoGroupInfo,
                         MemoTasksInfo: String): String;
begin
		Result := MemoDirInfo + NewLine
		        + NewLine
		        +	'Using GHC ' + GhcInstallVersion + ' installed at:' + NewLine
		        + Space + GhcInstallDir + NewLine
end;

procedure ErrorReportPageNotify(Sender: TWizardPage);
begin
  WizardForm.NextButton.Enabled := False;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  BinDir, Path: String;
begin
  if (CurUninstallStep = usPostUninstall)
     and (RegQueryStringValue(HKEY_CURRENT_USER, 'Environment', 'PATH', Path)) then
  begin
    BinDir := ExpandConstant('{app}\bin');
    if Pos(LowerCase(BinDir) + ';', Lowercase(Path)) <> 0 then
    begin
      StringChange(Path, BinDir + ';', '');
      RegWriteStringValue(HKEY_CURRENT_USER, 'Environment', 'PATH', Path);
    end;
  end;
end;

