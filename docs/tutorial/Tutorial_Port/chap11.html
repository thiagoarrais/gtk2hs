<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org">
  <meta http-equiv="CONTENT-TYPE" content=
  "text/html; charset=us-ascii">

  <title>Text Entries and Statusbars</title>
</head>

<body lang="en-US" text="#000000" link="#0000FF" vlink="#840084"
bgcolor="#FFFFFF" dir="ltr">
  <table summary="links to other pages" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <th colspan="3">
        <p align="center">Gtk2Hs Tutorial</p>
      </th>
    </tr>

    <tr valign="bottom">
      <td width="10%">
        <p align="left"><a href="chap10.html">&lt;&lt;&lt;
        Previous</a></p>
      </td>

      <td width="80%">
        <p align="center"><br></p>
      </td><!--
                <TD WIDTH=10%>
                        <P ALIGN=RIGHT><A HREF="chap12.html">Next &gt;&gt;&gt;</A></P>
                </TD>
                -->
    </tr>
  </table>
  <hr>

  <h2><a name="SEC-TEXTENTRIES" id="SEC-TEXTENTRIES"></a>Text
  Entries and Status Bars</h2>

  <p>The <i>Entry</i> widget allows text to be typed and displayed
  in a single line text box. A fairly large set of key bindings are
  supported by default. The user can choose between insert and
  overwite mode by toggling the Insert key.</p>

  <p>Create a new <i>Entry</i> widget with the following
  function.</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
entryNew :: IO Entry
</pre>
      </td>
    </tr>
  </table>

  <p>To replace or get the text which is currently within the
  <i>Entry</i> widget:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
entrySetText :: EntryClass self =&gt; self -&gt; String -&gt; IO ()

entryGetText :: EntryClass self =&gt; self -&gt; IO String
</pre>
      </td>
    </tr>
  </table>

  <p>If we don't want the contents of the <i>Entry</i> to be
  changed by someone typing into it, we can change its editable
  state. We can also set visibility (e.g. for passwords), the
  maximum number of characters (0 if no maximum), whether the entry
  has a frame or not, the number of characters to leave space for,
  and a few other attributes. Text completion is also possible (see
  <i>EntryCompletion</i> in the API documentation for its use). The
  <i>Entry</i> attributes, which, of course, can be accessed with
  <i>get</i> and <i>set</i> are:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
entryEditable :: EntryClass self =&gt; Attr self Bool  -- default True

entryVisibility :: EntryClass self =&gt; Attr self Bool  -- default True

entryMaxLength :: EntryClass self =&gt; Attr self Int -- 0 if no maximum, limit 66535

entryHasFrame :: EntryClass self =&gt; Attr self Bool -- default False

entryWidthChars :: EntryClass self =&gt; Attr self Int -- default -1, no space set
</pre>
      </td>
    </tr>
  </table>

  <p>The <i>Entry</i> type is an instance of <i>EditableClass</i>
  and many attributes and methods are defined there. Some
  particularly useful ones are:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
editableInsertText :: EditableClass self =&gt; self -&gt; String -&gt; Int -&gt; IO Int

editableDeleteText :: EditableClass self -&gt; Int -&gt; Int -&gt; IO ()

editableSelectRegion :: EditableClass self =&gt; self -&gt; Int -&gt; Int -&gt; IO ()

editableDeleteSelection :: EditableClass self -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>where the parameters of type <i>Int</i> denote the appropriate
  start or end positions. The user can also cut, copy and paste
  to/from the clipboard.</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
editableCutClipboard :: EditableClass self =&gt; self -&gt; IO ()

editableCopyClipboard :: EditableClass self =&gt; self -&gt; IO ()

editablePasteClipboard :: EditableClass self =&gt; self -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>These all take the current cursor position. You can get and
  set that position with:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
editableGetPosition :: EditableClass self =&gt; self -&gt; IO Int

editableSetPosition :: EditableClass self =&gt; self -&gt; Int
</pre>
      </td>
    </tr>
  </table>

  <p>The cursor is displayed before the character with the given
  (base 0) index in the widget. The value must be less than or
  equal to the number of characters in the widget. A value of -1
  indicates that the position should be set after the last
  character in the entry.</p>

  <p>The Editable class has a number of signals which use higher
  order functions (not discussed here). The <i>Entry</i> widget
  itself has a signal, which is sent after the user presses the
  Enter key:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
onEntryActivate :: EntryClass ec =&gt; ec -&gt; IO () -&gt; IO (ConnectId ec)
</pre>
      </td>
    </tr>
  </table>

  <p>There are also signals sent when text is copied, cut or pasted
  to the clipboard, and when the user toggles overwrite/insert
  mode.</p>

  <p>Statusbars are simple widgets used to display a text message.
  They keep a stack of the messages pushed onto them, so that
  popping the current message will re-display the previous text
  message. A statusbar has a resize grip by default, so the user
  can resize it.</p>

  <p>In order to allow different parts of an application to use the
  same statusbar to display messages, the statusbar widget issues
  Context Identifiers which are used to identify different "users".
  The message on top of the stack is the one displayed, no matter
  what context it is in. Messages are stacked in last-in-first-out
  order, not context identifier order. A statusbar is created
  with:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
statusbarNew :: IO Statusbar
</pre>
      </td>
    </tr>
  </table>

  <p>A new Context Identifier is generated by the following
  function, with a String used as textual description of the
  context:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
statusbarGetContextId :: StatusbarClass self =&gt; self -&gt; String -&gt; IO ContextId
</pre>
      </td>
    </tr>
  </table>

  <p>There are three functions that can operate on statusbars:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
statusbarPush :: StatusbarClass self =&gt; self -&gt; ContextId -&gt; String -&gt; IO MessageId

statusbarPop :: StatusbarClass self =&gt; self -&gt; ContextId -&gt; IO ()

statusbarRemove :: StatusbarClass self =&gt; self -&gt; ContextId -&gt; MessageId -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>The first, <i>statusbarPush</i> , is used to add a new message
  to the statusbar. It returns a <i>MessageId</i>, which can be
  passed later to <i>statusbarRemove</i> to remove the message with
  the given <i>ContextId</i> and <i>MessageId</i> from the
  statusbar's stack. Function <i>statusbarPop</i> removes the
  message highest in the stack with the given context
  identifier.</p>

  <p>Statusbars, like progress bars, are used to display messages
  to the user about some ongoing operation. We'll simulate such an
  operation in the example below, by testing whether the text the
  user submits (by pressing Enter) is the same as its reverse, and
  pushing the result on the stack. The user can then see the
  results by pressing the information button, which pops the stack
  of messages. The first time the stack is empty, so the button is
  greyed out using:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
widgetSetSensitivity :: WidgetClass self =&gt; self -&gt; Bool -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>Note that status bars would not be the first choice here,
  since there is no testing if the stack is empty, but the example
  does show how they can be applied. The resize handle of the
  status bar is not very clear, but it is there, at the bottom
  right.</p>

  <p><img src="./Images/GtkChap11.png" alt="GtkChap11.png" align=
  "bottom"></p><br>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
import Graphics.UI.Gtk

main :: IO ()
main= do
     initGUI
     window &lt;- windowNew
     set window [windowTitle := "Text Entry", containerBorderWidth := 10]

     vb &lt;- vBoxNew False 0
     containerAdd window vb

     hb &lt;- hBoxNew False 0
     boxPackStart vb hb PackNatural 0

     txtfield &lt;- entryNew
     boxPackStart hb txtfield PackNatural 5
     button &lt;- buttonNewFromStock stockInfo
     boxPackStart hb button PackNatural 0

     txtstack &lt;- statusbarNew
     boxPackStart vb txtstack PackNatural 0
     id &lt;- statusbarGetContextId txtstack "Line"

     widgetShowAll window
     widgetSetSensitivity button False

     onEntryActivate txtfield (saveText txtfield button txtstack id)
     onPressed button (statusbarPop txtstack id)
     onDestroy window mainQuit
     mainGUI

saveText :: Entry -&gt; Button -&gt; Statusbar -&gt; ContextId -&gt; IO ()
saveText fld b stk id = do
         txt &lt;- entryGetText fld
         let mesg | txt == reverse txt = "\"" ++ txt ++ "\""  ++
                                         " is equal to its reverse"
                  | otherwise =  "\"" ++ txt ++ "\""  ++
                                 " is not equal to its reverse"
         widgetSetSensitivity b True
         msgid &lt;- statusbarPush stk id mesg
         return ()
</pre>
      </td>
    </tr>
  </table><br>

  <table summary="links to other pages" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr valign="top">
      <td width="33%">
        <p align="left"><a href="chap10.html">&lt;&lt;&lt;
        Previous</a></p>
      </td>

      <td width="34%">
        <p align="center"><a href="chap1.html">Home</a></p>
      </td><!--
                <TD WIDTH=33%>
                        <P ALIGN=RIGHT><A HREF="chap12.html">Next &gt;&gt;&gt;</A></P>
                </TD>
                -->
    </tr>

    <tr valign="top">
      <td width="33%">
        <p align="left">Dialogs, Progress Bars</p>
      </td>

      <td width="34%">
        <p align="center"><br></p>
      </td>

      <td width="33%">
        <p align="right">To be continued</p>
      </td>
    </tr>
  </table>
</body>
</html>
