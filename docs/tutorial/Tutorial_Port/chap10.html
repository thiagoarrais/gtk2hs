<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org">
  <meta http-equiv="CONTENT-TYPE" content=
  "text/html; charset=us-ascii">

  <title>Dialogs, Stock Items and Progress Bars</title>
</head>

<body lang="en-US" text="#000000" link="#0000FF" vlink="#840084"
bgcolor="#FFFFFF" dir="ltr">
  <table summary="links to other pages" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <th colspan="3">
        <p align="center">Gtk2Hs Tutorial</p>
      </th>
    </tr>

    <tr valign="bottom">
      <td width="10%">
        <p align="left"><a href="chap9.html">&lt;&lt;&lt;
        Previous</a></p>
      </td>

      <td width="80%">
        <p align="center"><br></p>
      </td><!--
                <TD WIDTH=10%>
                        <P ALIGN=RIGHT><A HREF="chap11.html">Next &gt;&gt;&gt;</A></P>
                </TD> 
                -->
    </tr>
  </table>

  <h2><a name="SEC-DIALOGS" id="SEC-DIALOGS"></a>Dialogs, Stock
  Items and Progress Bars</h2>

  <p>A dialog is an example of a composite widget. It consists of a
  window, an upper part which is a vertical box, and an action area
  which is a horizontal box. By default, both parts are separated
  by a horizontal separator.</p>

  <p>The <i>Dialog</i> widget can be used for pop-up messages to
  the user, and other similar tasks. The basic functions needed
  are:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
dialogNew :: IO Dialog

dialogRun :: DialogClass self =&gt; self -&gt; IO ResponseID
</pre>
      </td>
    </tr>
  </table>

  <p>You add buttons into the action area with:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
dialogAddButton :: DialogClass self =&gt; self -&gt; String -&gt; ResponseId -&gt; IO Button
</pre>
      </td>
    </tr>
  </table>

  <p>Any widget can be added in a similar way with
  <i>dialogAddActionWidget.</i></p>

  <p>The <i>String</i> in <i>dialogAddButton</i> can be the text of
  the button, but since dialogs are mostly used for standard
  situations a <i>StockItem</i> will usually be more
  appropriate.</p>

  <p><i>StockItems</i> are resources which are known throughout
  Gtk2Hs, such as standard <i>IconSets.</i> You can define your
  own, but many useful ones are listed in the
  <i>Graphics.UI.Gtk.General.StockItems</i> module. They have an
  identifier <i>StockId</i> ,which is a type synonym for
  <i>String</i>. From this identifier a widget (usually a button)
  with the appropriate standard text and icon is automatically
  selected.</p>

  <p>If you use a <i>StockId</i> when adding a button to a dialog,
  you can also use a pre-defined <i>ResponseId</i> constructor with
  the buttons. (<i>ResponseId</i> is not a <i>String.</i>)
  Customized responses may be constructed with <i>ResponseUser
  Int</i> .</p>

  <p>Whenever a dialog button is pressed, its response is passed to
  the calling application through <i>dialogRun</i>. According to
  the Gtk2Hs API documentation <i>dialogRun</i> blocks in a
  recursive main loop until the dialog either emits the response
  signal, or is destroyed. The default mode is modal, which means
  the user cannot access any other window while <i>dialogRun</i> is
  waiting for a response.</p>

  <p>Progress bars are used to show the status of an ongoing
  operation.</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
progressBarNew :: IO ProgressBar
</pre>
      </td>
    </tr>
  </table>

  <p>Though there is only one type, there are two distinct ways to
  use a progress bar. If it is known how much of the task has been
  completed, the fraction (between 0.0 and 1.0 inclusive) can be
  set with:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
progressBarSetFraction :: ProgressBarClass self =&gt; self -&gt; Double -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>This causes the progress bar to be filled in with the
  specified amount (between 0.0 and 1.0). To trace the progress
  this function should be called at regular times during the
  operation.</p>

  <p>When it is not known how much of the operation has been
  completed, the bar can be moved back and forth with:</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
progressBarPulse :: ProgressBarClass self =&gt; self -&gt; IO ()
</pre>
      </td>
    </tr>
  </table>

  <p>This function must also be called repeatedly, to show that the
  activity is going on. There are several other functions to
  control the display of a progress bar, like orientation,
  additional text etc.; they are fairly trivial.</p>

  <p>Application, however, is not trivial because progress bars are
  usually applied with timeouts or other such functions to give the
  illusion of multitasking. With concurrent Haskell you can also
  use threads and communication between threads.</p>

  <p>In the following example we'll simulate an activity using
  <i>timeoutAdd</i>, which runs a function repeatedly at the
  interval specified, in milliseconds. The function is passed to
  <i>timeoutAdd</i> and must return a type of <i>IO Bool</i>. When
  true the timeout is run again, when false it stops. The priority
  of <i>timeoutAdd</i> is <i>priorityDefault</i> of type
  <i>Priority</i>.</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="0" bgcolor="#E0E0E0">
    <col width="256*">

    <tr>
      <td width="100%">
        <pre>
timeoutAdd :: IO Bool -&gt; Int -&gt; IO HandlerId
</pre>
      </td>
    </tr>
  </table>

  <p>In the example we define the function <i>showPulse</i> , which
  causes the progress bar to pulse and always returns <i>IO
  True.</i> The pulse step, the amount which the indicator moves
  through the bar, is set to 1.0 with
  <i>progressBarSetPulseStep</i>.</p>

  <p><br>
  <img src="./Images/GtkChap10.png" align="bottom" alt=
  "GtkChap10"><br></p>

  <p>The example is somewhat atypical of the use of a dialog, since
  we keep it to show the progress after the user has pressed the
  apply button. To close the application the dialog must be
  destroyed by destroying the window. The close and cancel buttons
  don't work after apply has been selected. If selected, instead of
  Apply, the first time, the application will close. This is done
  by testing the response from dialogRun.</p>

  <p>If the dialog widget is destroyed, <i>mainQuit</i> is called.
  As mentioned above, a <i>Dialog</i> consists of a window and two
  boxes. The boxes must be accessed through special functions, and
  the progress bar is packed into the upper part using
  <i>dialogGetUpper</i>. The buttons in a dialog are visible by
  default, but the widgets in the upper part are not. A
  <i>Dialog</i> is an instance of the <i>WindowClass,</i> and so we
  can set the title and/or default length and height if we
  want.</p>

  <p style="font-style: normal">A trivial feature to watch out for:
  a widget can only be made visible if its parent is visible. So,
  to show the progress bar, we use <i>widgetShowAll</i> on the
  vertical box and not <i>widgetShow</i> on the progress bar.</p>

  <table summary="Haskell code" width="100%" border="0"
  cellpadding="2" cellspacing="2" bgcolor="#E0E0E0">
    <tr>
      <td>
        <pre>
import Graphics.UI.Gtk

main :: IO ()
main = do
     initGUI
     
     dia &lt;- dialogNew
     set dia [windowTitle := "Time Flies"]
     dialogAddButton dia stockApply  ResponseApply
     dialogAddButton dia stockCancel ResponseCancel
     dialogAddButton dia stockClose  ResponseClose

     pr &lt;- progressBarNew
     progressBarSetPulseStep pr 1.0

     upbox &lt;- dialogGetUpper dia
     boxPackStart upbox pr PackGrow 10
     widgetShowAll upbox
     
     answer &lt;- dialogRun dia
     if answer == ResponseApply 
           then do tmhandle &lt;- timeoutAdd (showPulse pr) 500
                   return ()
           else widgetDestroy dia
 
     onDestroy dia mainQuit
     mainGUI

showPulse :: ProgressBar -&gt; IO Bool
showPulse b = do progressBarPulse b
                 return True
</pre>
      </td>
    </tr>
  </table>
  <hr>

  <table summary="links to other pages" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr valign="top">
      <td width="33%">
        <p align="left"><a href="chap9.html">&lt;&lt;&lt;
        Previous</a></p>
      </td>

      <td width="34%">
        <p align="center"><a href="chap1.html">Home</a></p>
      </td><!--
                <TD WIDTH=33%>
                        <P ALIGN=RIGHT><A HREF="chap11.html">Next &gt;&gt;&gt;</A></P>
                </TD>
                -->
    </tr>

    <tr valign="top">
      <td width="33%">
        <p align="left">Arrows and Tooltips</p>
      </td>

      <td width="34%">
        <p align="center"><br></p>
      </td>

      <td width="33%">
        <p align="right">To be continued</p>
      </td>
    </tr>
  </table>

  <p><br>
  <br></p>
</body>
</html>
